# Learnings and Use Cases — Multi-Webserver Docker VM

## What this project demonstrates

This project proves that one VM can host multiple isolated services
securely and efficiently using Docker containerization. You learn the
complete journey from bare VM to live services exposed to the host.

---

## Key learnings

1. **Docker fundamentals**
   - Installing Docker and verifying the engine.
   - Running, stopping, and managing containers.
   - Mapping local folders as volumes for web content.
   - Persistent restarts using `--restart unless-stopped`.

2. **Container networking**
   - Mapping host → container ports (`-p 8091:80`).
   - Understanding network isolation per container.
   - Using port forwarding and SSH tunnels.

3. **System administration**
   - Managing Ubuntu services.
   - Adjusting firewall rules (UFW).
   - Inspecting ports using `ss`, `netstat`, and `curl`.

4. **Virtualization concepts**
   - NAT network configuration in VirtualBox.
   - Bridging ports from VM to host system.
   - Ensuring host reachability through forwarding.

5. **Automation & scalability**
   - Using `docker-compose` to manage multiple services.
   - Conceptualizing how the same model extends to Kubernetes
     or cloud load balancers.

---

## Real-world use cases

- **Dev/Test sandbox**
  Ideal for local development when you need multiple microservices
  or static sites hosted on one machine.

- **Training & demos**
  Perfect for educational environments or live workshops where you
  demonstrate containerization fundamentals.

- **Prototype environments**
  When building a quick proof-of-concept before deploying to AWS EC2,
  GCP VM, or Azure VM.

- **CI/CD validation**
  Jenkins, GitHub Actions, or GitLab runners can spin up such
  environments temporarily for integration testing.

- **Local multi-site hosting**
  Hosting multiple static dashboards, documentation pages, or internal
  tools on one dev VM.

---

## Why this matters

This project mirrors real infrastructure patterns where:
- You isolate workloads with Docker containers.
- You manage multiple services on one node.
- You control inbound/outbound network mappings securely.
- You validate configurations before cloud deployment.

It bridges the gap between **bare-metal administration** and **cloud
container orchestration**, letting you practice DevOps fundamentals
in a safe, local, reproducible setup.

---

## Skills strengthened

- Linux server management
- Docker and container lifecycle
- Network mapping & forwarding
- Firewall and service hardening
- YAML configuration (`docker-compose.yml`)
- Problem solving with logs and CLI tools
- Automation mindset for repeatable setups

---

## Next practical goals

1. Replace Nginx with a Node.js app in one container.
2. Add a third container with Flask (Python) to test multi-language apps.
3. Configure Nginx reverse proxy container to unify under one domain.
4. Deploy on AWS EC2 with security groups and a custom domain via Route53.
5. Integrate CI/CD pipeline to auto-build and deploy both sites.
